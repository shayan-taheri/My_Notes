{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf510
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;\f2\fmodern\fcharset0 Courier-Bold;
\f3\fnil\fcharset178 GeezaPro;\f4\fnil\fcharset0 LucidaGrande;\f5\fnil\fcharset0 Verdana;
}
{\colortbl;\red255\green255\blue255;\red0\green45\blue153;\red217\green11\blue0;\red0\green0\blue169;
\red235\green234\blue255;\red143\green143\blue143;\red178\green178\blue199;\red29\green96\blue0;}
\margl1440\margr1440\vieww20380\viewh13940\viewkind0
\deftab720
\pard\pardeftab720

\f0\b\fs36 \cf0 Pointers and Constants
\b0\fs28 \
\
\pard\pardeftab720

\b \cf0 1)
\b0  
\f1 \cf2 const int myconstant = 10
\f0 \cf0 \
\
An 
\f1 \cf2 int
\f0 \cf0  which can't change value. Similar to 
\f1 \cf2 #define
\f0 \cf0  in C but better.\
\

\b 2)
\b0  
\f1 \cf2 const int * myconstant
\f0 \cf0 \
\
Variable pointer to a constant integer.\
\

\b 3)
\b0  
\f1 \cf2 int const * myconstant
\f0 \cf0 \
\
Same as above.\
\

\b 4)
\b0  
\f1 \cf2 int * const myconstant
\f0 \cf0 \
\
\ul Constant pointer\ulnone  to a variable integer.\
\

\b 5)
\b0  
\f1 \cf2 int const * const myconstant
\f0 \cf0 \
\
Constant pointer to a constant integer.\
\

\b 6)
\b0  
\f1 \cf2 void mymethod(QString const & myparamater)
\f0 \cf0 \
\ul \
myparamater\ulnone  will not be altered by the method. 
\f2\b\fs32 \cf2 &
\f0\b0\fs28 \cf0  means \ul it can be altered\ulnone  but here we just want it to be used because it saves taking a copy.\
\

\b Reason
\b0 : Because of 
\f2\b \cf2 const
\f0\b0 \cf0  before 
\f2\b\fs32 \cf2 &
\f0\b0\fs28 \cf0 .\
\

\b 7)
\b0  
\f1 \cf2 class myclass \{\
\
void mymethod() const;\
int myvariable; \}
\f0 \cf0 \
\ul \
\pard\pardeftab720

\f1 \cf2 \ulc2 mymethod()
\f0 \cf0 \ulnone  \ul will not alter any member variable\ulnone  (
\f1 \cf2 myvariable
\f0 \cf0 ), this means you can call the method from a const variable.\
\

\b 8)
\b0  
\f1 \cf2 const int * const mymethod (const int * const &something) const
\f0 \cf0 \
\
It will return a pointer which is constant and points to a constant integer, the method doesn't alter either the variable pointed to by the parameter or the pointer itself and it doesn't alter any of the member variables of the object the method is it.\
\

\b VERY IMPORTANT For "8"
\b0 :\
\
A. Return of Function = 
\f1 \cf2 const int
\f0 \cf0  = It should be constant and integer\
B. Defining a Pointer for Function = 
\f1 \cf2 * const
\f0 \cf0  = It should be constant\
C. Defining the Function = 
\f1 \cf2 mymethod ()\

\f0 \cf0 \

\b Notice (Important)
\b0 :\
\pard\tx720\pardeftab720
\cf0 1) 
\b\fs32 \cf3 &
\b0\fs28 \cf0  is the \ul reference operator\ulnone  and can be read as "
\b \cf3 address of
\b0 \cf0 ".\
2) 
\b\fs32 \cf3 *
\b0\fs28 \cf0  is the \ul dereference operator\ulnone  and can be read as "
\b \cf3 value pointed by
\b0 \cf0 ".\
\pard\tx720\pardeftab720\qr
\cf0 \
\pard\tx720\pardeftab720\qr
\cf0 \
\pard\tx720\pardeftab720\rtlpar\qr

\f3\b\fs32 \cf0 \'e4\uc0\u1705 \'ca\'e5 
\f4 \uc0\u8235 :
\f3 \uc0\u8236  
\b0 \uc0\u1740 \u1705  
\f4 Pointer
\f3  \'e5\'e3\'c7\'e4 
\f4 Random
\f3  
\f4 Access
\f3  
\f4 Iterator
\f3  \'e3\uc0\u1740  \'c8\'c7\'d4\'cf\uc0\u8235 .\uc0\u8236  \'cf\'d1 \'e4\'ca\uc0\u1740 \'cc\'e5 \'da\'e1\'c7\'e6\'e5 \'c8\'d1 \'c7\'dd\'d2\'c7\u1740 \'d4 \u1740 \'c7 \u1705 \'c7\'e5\'d4 \'c2\'e4 \'a1 \'e3\u1740  \'ca\'e6\'c7\'e4 \'e3\'de\'c7\'cf\u1740 \'d1 \'e3\'ce\'ca\'e1\'dd\u1740  \'d1\'c7 \'c8\'e5 \'c2\'e4 \'ca\'ce\'d5\u1740 \'d5 \'cf\'c7\'cf. \'cf\'d1 \'d5\'e6\'d1\'ca\u1740  \u1705 \'e5 
\f4 Forward
\f3  
\f4 Iterator
\f3  \'d1\'c7 \'ca\'e4\'e5\'c7 \'e3\uc0\u1740  \'ca\'e6\'c7\'e4 \'c7\'dd\'d2\'c7\u1740 \'d4 \'cf\'c7\'cf \'e6 
\f4 Biderectional
\f3  
\f4 Iterator
\f3  \'ca\'e4\'e5\'c7 \'de\'c7\'c8\'e1\uc0\u1740 \'ca \'c7\'dd\'d2\'c7\u1740 \'d4 \u1740 \'c7 \u1705 \'c7\'e5\'d4 \'cf\'c7\'d1\'cf \'e6\'e1\u1740  \'e4\'e3\u1740  \'ca\'e6\'c7\'e4 \ul \'e3\'de\'c7\'cf\uc0\u1740 \'d1 \'e3\'ce\'ca\'e1\'dd\u1740 \ulnone  \'d1\'c7 \'c8\'e5 \'c2\'e4 \'ca\'ce\'d5\uc0\u1740 \'d5 \'cf\'c7\'cf.
\f0\fs28 \
\pard\tx720\pardeftab720\qr
\cf0 \
\pard\tx720\pardeftab720\qr

\f3\b\fs32 \cf0 \'e4\uc0\u1705 \'ca\'e5 
\f4 \uc0\u8235 :
\f3 \uc0\u8236  
\b0 \'ca\'c7\uc0\u1740 \'81 \'ca\'da\'d1\u1740 \'dd \'d4\'cf\'e5 \'c8\'d1\'c7\u1740  \u1740 \u1705  \'c7\'d4\'c7\'d1\'e5 \'90\'d1 \'a1 \ul \'ca\'c7\uc0\u1740 \'81 \'e3\'de\'cf\'c7\'d1\u1740  \'c7\'d3\'ca \u1705 \'e5 \'c8\'e5 \'c2\'e4 \'c7\'d4\'c7\'d1\'e5 \'e3\u1740  \u1705 \'e4\'cf\ulnone \uc0\u8235 .
\f0\fs28 \uc0\u8236 \
\pard\tx720\pardeftab720
\cf0 \
\pard\tx720\pardeftab720\qr

\f3\b\fs32 \cf0 \'e4\uc0\u1705 \'ca\'e5
\f0\b0  
\f3\b \'c8\'d3\uc0\u1740 \'c7\'d1
\f0\b0  
\f3\b \'e3\'e5\'e3
\f0\b0 \uc0\u8235 :\uc0\u8236  
\f3 \'d2\'e3\'c7\'e4\uc0\u1740 
\f0  
\f3 \uc0\u1705 \'e5
\f0  
\f3 \uc0\u1740 \u1705 
\f0  
\f3 \'ca\'c7\'c8\'da
\f0  
\f3 \'cf\'d1
\f0  
\f3 \uc0\u1740 \u1705  \u1705 \'e1\'c7\'d3 \'ca\'da\'d1\u1740 \'dd \'e3\u1740  \'90\'d1\'cf\'cf \'a1 \'c7\'90\'d1 \'c8\'da\'cf \'c7\'d2 
\f4 \uc0\u8235 () 
\f3 \'ca\'c7\'c8\'da
\f4  
\f3 \uc0\u1705 \'c7\'e4\'d3\'ca
\f4  
\f3 \'c8\uc0\u1740 \'c7\u1740 \'cf
\f4  
\f3 \'c8\'e5
\f4  
\f3 \'c7\uc0\u1740 \'e4
\f4  
\f3 \'e3\'da\'e4\uc0\u1740 
\f4  
\f3 \'c7\'d3\'ca
\f4  
\f3 \uc0\u1705 \'e5 \'c2\'e4 \'ca\'c7\'c8\'da \'e4\'e3\u1740  \'ca\'e6\'c7\'e4\'cf \'e5\u1740 \'8d \u1705 \'cf\'c7\'e3 \'c7\'d2 \'c7\'da\'d6\'c7\u1740  \'c2\'e4 \u1705 \'e1\'c7\'d3 \'d1\'c7 \'ca\'db\u1740 \u1740 \'d1 \'cf\'e5\'cf \'e6 \'ca\'e4\'e5\'c7 \'e3\u1740  \'ca\'e6\'c7\'e4\'cf \'c7\'d2 \'c2\'e4 \'e5\'c7 \'c7\'d3\'ca\'dd\'c7\'cf\'e5 \'e4\'e3\'c7\u1740 \'cf 
\f4 (
\f3 \uc0\u8236 \'e3\'cb\'c7\'e1 \'cf\'d1 \'e3\'e6\'c7\'d1\'cf \uc0\u1783  \'e6 \u1784 
\f4 \uc0\u8235 )
\f3 .\uc0\u8236 \
\
\pard\tx720\pardeftab720

\f0\b\fs28 \cf0 Complete Explanation:
\f3\b0\fs32 \
\
\pard\pardeftab720

\f1\fs28 \cf4 \cb5 void\cf0  \cf4 const\cf0  f()
\f5 \cb1  
\f0 is equivalent to
\f5  
\f1 \cf4 \cb5 const\cf0  \cf4 void\cf0  f()
\f0 \cb1 , which means the return type (in this case a void) is const.
\f5 \
\

\f1 \cf4 \cb5 void\cf0  f() \cf4 const
\f5 \cf0 \cb1  
\f0 makes the function itself const. This only really has meaning for member functions. Making a member function const means that it 
\b cannot
\b0  call any \ul non-const\ulnone  \ul member functions\ulnone , and it 
\b cannot
\b0  change any \ul member variables\ulnone  (but \ul it can call 
\b any
\b0  non-member\ulnone ). It also means that the function can be called via a const object of the class (A regular function member cannot be called by const object of the class):
\f5\fs24 \
\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth400\clftsWidth3 \clminw400 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalt \clcbpat5 \clwWidth10780\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrs\brdrw20\brdrcf7 \clbrdrl\brdrs\brdrw20\brdrcf7 \clbrdrb\brdrs\brdrw20\brdrcf7 \clbrdrr\brdrs\brdrw20\brdrcf7 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\qr

\f1 \cf6 1\
2\
3\
4\
5\
6\
7\
8\
9\
10\
11\
12\
13\
14\
15\
16\
17\cell 
\pard\intbl\itap1\pardeftab720
\cf4 class\cf0  A\
\{\
\cf4 public\cf0 :\
  \cf4 void\cf0  Const_No();   \cf8 // nonconst member function\cf0 \
  \cf4 void\cf0  Const_Yes() \cf4 const\cf0 ; \cf8 // const member function\cf0 \
\};\
\
\
\cf8 //-----------\cf0 \
\
A  obj_nonconst;  \cf8 // nonconst object\cf0 \
obj_nonconst.Const_No();  \cf8 // works fine\cf0 \
obj_nonconst.Const_Yes(); \cf8 // works fine\cf0 \
\
\cf4 const\cf0  A obj_const = A(); \cf8 // const object\cf0 \
obj_const.Const_Yes(); \cf8 // works fine (
\f2\b const object can call const function
\f1\b0 )\cf0 \
obj_const.Const_No();  \cf8 // ERROR (
\f2\b const object cannot call non-const function
\f1\b0 )\cell \lastrow\row
}