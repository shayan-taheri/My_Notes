{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf510
{\fonttbl\f0\fmodern\fcharset0 Courier-Bold;\f1\froman\fcharset0 Times-Roman;\f2\fswiss\fcharset0 Helvetica;
\f3\fmodern\fcharset0 Courier;\f4\fnil\fcharset178 GeezaPro;\f5\fnil\fcharset0 LucidaGrande;
}
{\colortbl;\red255\green255\blue255;\red217\green11\blue0;\red133\green0\blue175;\red0\green45\blue153;
\red201\green113\blue0;\red164\green8\blue0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww28920\viewh17800\viewkind0
\deftab720
\pard\pardeftab720\sa425

\f0\b\fs28 \cf0 *\cf2  getopt()
\f1 \cf0  
\f2 Function
\f1 \
\pard\pardeftab720\sa320

\f2\b0 \cf0 1) Needed the header file: 
\f0\b \cf3 unistd.h
\f2\b0 \cf0 \
\pard\pardeftab720
\cf0 2) Variables:\
\
a. 
\f3 \cf4 int 
\f0\b opterr
\f2\b0 \cf0 \
\
\ul Default\ulnone : 
\f3 \cf5 opterr != 0
\f2 \cf0   -->  The function prints an error message to the standard error stream if it encounters an unknown option character or an option with a missing required argument\
\pard\pardeftab720\sa320
\cf0 \ul \ulc0 Error\ulnone : 
\f3 \cf5 opterr == 0
\f2 \cf0 \
\pard\pardeftab720
\cf0 b. 
\f3 \cf4 int 
\f0\b optopt
\f2\b0 \cf0 \
\
\pard\pardeftab720\sa320
\cf0 For storing an unknown option character --> Using for diagnostic messages\
\pard\pardeftab720
\cf0 c. 
\f3 \cf4 int 
\f0\b optind
\f2\b0 \cf0 \
\
\pard\pardeftab720\sa320
\cf0 This variable is set by 
\f3 \cf6 getopt
\f2 \cf0  to the index of the next element of the 
\f3 \cf6 argv
\f2 \cf0  array to be processed. Once 
\f3 \cf6 getopt
\f2 \cf0  has found all of the \ul option arguments\ulnone , you can use this variable to determine where the remaining \ul non-option arguments\ulnone  begin. The initial value of this variable is 1.\
\pard\pardeftab720
\cf0 c. 
\f3 \cf4 char* 
\f0\b optarg
\f2\b0 \cf0 \
\
\pard\pardeftab720\sa320
\cf0 This variable is set by 
\f3 \cf6 getopt
\f2 \cf0  to point at 
\b \ul the value of the option argument
\b0 \ulnone , for those options that accept \ul arguments\ulnone .\

\b Very Important:
\b0  
\f0\b \cf4 optarg
\f2\b0 \cf0  is a \ul pointer\ulnone  to the argument that we have in command.\
\pard\pardeftab720
\cf0 3) Function:\
\
\pard\pardeftab720

\f3 \cf4 int getopt (int argc, char *const *argv, const char *options) 
\f0\b\fs36 \cf0 = 
\f3\b0\fs28 \cf4 int getopt (int argc, char *const argv[], const char *optstring);\uc0\u8232 extern char *optarg;\u8232 extern int optind, opterr, optopt;
\f2 \cf0 \
\
\pard\pardeftab720\sa320
\cf0 - 
\f3 \cf4 argc
\f2 \cf0  = Argument Count\
- 
\f3 \cf4 argv
\f2 \cf0  = Argument Array (that has been defined by User)\
- 
\f3 \cf4 optstring
\f2 \cf0  = A string of recognized option characters --> Allowable Options\
- 
\f3 \cf4 optind
\f2 \cf0  = The index of the next element of the 
\f0\b argv[]
\f2\b0  vector to be processed\
- 
\f3 \cf4 optarg
\f2 \cf0  = For storing \ul the argument's value\ulnone  of an option\
\pard\pardeftab720\sa266

\b \cf0 Important:
\b0  If a character is followed by a colon 
\b \cf6 (\'91:\'92)
\b0 \cf0 , the option takes an argument\
\pard\pardeftab720\sa320
\cf0 The 
\f3 \cf6 getopt
\f2 \cf0  function gets \ul the next option argument\ulnone  from \ul the argument list\ulnone  specified by the 
\f3 \cf6 argv
\f2 \cf0  and 
\f3 \cf6 argc
\f2 \cf0  arguments. Normally these values come directly from the arguments received by main.\
The 
\f3 \cf6 \ul \ulc6 options
\f2 \cf0 \ulc0  argument\ulnone  is a string that specifies 
\b \ul the option characters
\b0 \ulnone  that are valid for this program.\
An 
\b \ul option character
\b0 \ulnone  in this string can be followed by a colon 
\b \cf6 (\'91:\'92)
\b0 \cf0  to indicate that it takes a 
\b \ul required argument
\b0 \ulnone .\

\b Very Important:
\b0  
\f0\b \cf6 getopt
\f3\b0  
\f2 \cf0 function can find one option in each iteration. So, we should use this function in a loop. If the function can find an option in 
\f0\b \cf4 optstring
\f2\b0 \cf0  then the function will return \ul the option\ulnone  which has been found. If the function couldn't find an option in 
\f0\b \cf4 optstring
\f2\b0 \cf0  then it would return 
\b \cf2 ("?")
\b0 \cf0 . At the end of the processing options when there wouldn't be any option, the function will return 
\b\fs32 \cf2 -1
\b0\fs28 \cf0 .\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0
\b \cf0 Notice 1:
\b0  A 
\b \ul switch statement
\b0 \ulnone  is used to dispatch on \ul the return value\ulnone  from 
\f0\b \cf6 getopt
\f2\b0 \cf0 . In typical use, each case just sets a variable that is used later in the program.\
\ls1\ilvl0
\b Notice 2:
\b0  A second loop is used to process the remaining non-option arguments.
\f1 \
\pard\pardeftab720

\f3 \cf0      \

\f2\b Example:\
\
\pard\pardeftab720

\f3\b0\fs24 \cf0 #include <unistd.h>\
#include <stdio.h>\
...\
int c;\
char *filename;\
extern char *optarg;\
extern int optind, optopt, opterr;\
...\
while ((c = getopt(argc, argv, ":abf:")) != -1) \{\
    switch(c) \{\
    case 'a':\
        printf("a is set\\n");\
        break;\
    case 'b':\
        printf("b is set\\n");\
        break;\
    case 'f':\
        filename = optarg;\
        printf("filename is %s\\n", filename);\
        break;\
    case ':':\
        printf("-%c without filename\\n", optopt);\
        break;\
    case '?':\
        printf("unknown arg %c\\n", optopt);\
        break;\
    \}\
\}\
\
\pard\pardeftab720\qr

\f4\fs36 \cf0 \'e4\uc0\u1705 \'ca\'e5 
\f5 \uc0\u8235 :
\f4 \uc0\u8236  \'c7\uc0\u1740 \'e4 \'ca\'c7\'c8\'da \'c8\'d1\'c7\u1740  \'ca\'cc\'d2\u1740 \'e5 \'dd\'d1\'e3\'c7\'e4 \'e5\'c7\u1740  \'cf\'c7\'cf\'e5 \'d4\'cf\'e5 \'c8\'e5 \'e6\'d3\u1740 \'e1\'e5 \u1705 \'c7\'d1\'c8\'d1 \'c7\'d3\'ca\'dd\'c7\'cf\'e5 \'e3\u1740  \'90\'d1\'cf\'cf \'ca\'c7 \'c8\'e5 \'ca\'e6\'c7\'e4 \u1705 \'c7\'d1\u1740  \u1705 \'e5 \u1705 \'c7\'d1\'c8\'d1 \'e3\u1740  \'ce\'e6\'c7\'e5\'cf \'d1\'c7 \'c7\'e4\'cc\'c7\'e3 \'cf\'c7\'cf\uc0\u8235 .\uc0\u8236  \'dd\'d1\'e3\'c7\'e4\uc0\u1740  \u1705 \'e5 \'ca\'e6\'d3\'d8 \u1705 \'c7\'d1\'c8\'d1 \'cf\'c7\'cf\'e5 \'e3\u1740  \'d4\'e6\'cf \'e3\u1740  \'ca\'e6\'c7\'e4\'cf \'d4\'c7\'e3\'e1 \'c2\'81\'d4\'e4 \u1740 \'c7 \'90\'d2\u1740 \'e4\'e5 \'e5\'c7\u1740 \u1740 \
\'c8\'c7\'d4\'cf \uc0\u1705 \'e5 \'e5\'d1 \u1705 \'cf\'c7\'e3 \'c7\'d2 \'c7\u1740 \'e4 \'c2\'81\'d4\'e4 \'e5\'c7 \'e3\u1740  \'ca\'e6\'c7\'e4\'cf \u1740 \u1705  \'c2\'d1\'90\'e6\'e3\'c7\'e4 \'d1\'c7 \'cf\'d1 \'c8\'d1 \'90\u1740 \'d1\'cf\uc0\u8235 .\uc0\u8236  \'c2\'81\'d4\'e4 \'e5\'c7 \'cd\'c7\'e1\'c7\'ca \'e3\'ce\'ca\'e1\'dd\uc0\u1740  \'e5\'d3\'ca\'e4\'cf \u1705 \'e5 \'e3\u1740  \'ca\'e6\'c7\'e4 \'c8\'d1\'c7\u1740  \'c7\'cc\'d1\'c7\u1740  \u1740 \u1705  \'dd\'d1\'e3\'c7\'e4 \'cf\'d1 \'e4\'d9\'d1 \'90\'d1\'dd\'ca\uc0\u8235 .\uc0\u8236  \'e3\'cb\'e1\'c7 \uc0\u1740 \u1705  \'c2\'81\'d4\'e4 \'e3\u1740  \'ca\'e6\'c7\'e4\'cf \'e4\'d4\'c7\'e4 \'cf\'e5\'e4\'cf\'e5 \'c7\'e4\'cc\'c7\'e3 \u1740 \u1705  \u1705 \'c7\'d1 \u1740 \'c7 \'ca\'c7\'c8\'da\
\'c8\'d1\'c7\uc0\u1740  \u1705 \'c7\'d1\'c8\'d1 \'c8\'c7\'d4\'cf\uc0\u8235 .\uc0\u8236  \uc0\u1740 \u1705  \'c2\'d1\'90\'e6\'e3\'c7\'e4 \'e3\u1740  \'ca\'e6\'c7\'e4\'cf \'e6\u1740 \'8e\'90\u1740  \'c7\u1740  \'d1\'c7 \'c8\'d1\'c7\u1740  \u1740 \u1705  \'c2\'81\'d4\'e4 \'c8\'e5 \'e6\'cc\'e6\'cf \'c2\'e6\'d1\'cf\uc0\u8235 .\uc0\u8236  \'e3\'cb\'e1\'c7 \uc0\u1740 \u1705  \'c2\'d1\'90\'e6\'e3\'c7\'e4 \'e3\u1740  \'ca\'e6\'c7\'e4\'cf \'c8\u1740 \'c7\'e4 \u1705 \'e4\'e4\'cf\'e5 \'ca\'da\'cf\'c7\'cf \'cf\'dd\'da\'c7\'ca \'ca\u1705 \'d1\'c7\'d1 \u1740 \u1705  \'c2\'81\'d4\'e4 \'c8\'c7\'d4\'cf \u1740 \'c7 \'c8\'e5 \'da\'e4\'e6\'c7\'e4 \u1740 \u1705  \'e3\'de\'cf\'c7\'d1 \'cf\'d1 \u1740 \u1705  \'ca\'c7\'c8\'da \'c8\'e5 \u1705 \'c7\'d1 \'d1\'e6\'cf\uc0\u8235 .\uc0\u8236 }